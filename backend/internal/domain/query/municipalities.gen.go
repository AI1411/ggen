// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"g_gen/internal/domain/model"
)

func newMunicipality(db *gorm.DB, opts ...gen.DOOption) municipality {
	_municipality := municipality{}

	_municipality.municipalityDo.UseDB(db, opts...)
	_municipality.municipalityDo.UseModel(&model.Municipality{})

	tableName := _municipality.municipalityDo.TableName()
	_municipality.ALL = field.NewAsterisk(tableName)
	_municipality.ID = field.NewInt32(tableName, "id")
	_municipality.PrefectureCode = field.NewString(tableName, "prefecture_code")
	_municipality.OrganizationCode = field.NewString(tableName, "organization_code")
	_municipality.PrefectureNameKanji = field.NewString(tableName, "prefecture_name_kanji")
	_municipality.MunicipalityNameKanji = field.NewString(tableName, "municipality_name_kanji")
	_municipality.PrefectureNameKana = field.NewString(tableName, "prefecture_name_kana")
	_municipality.MunicipalityNameKana = field.NewString(tableName, "municipality_name_kana")
	_municipality.IsActive = field.NewBool(tableName, "is_active")
	_municipality.Prefecture = municipalityBelongsToPrefecture{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Prefecture", "model.Prefecture"),
	}

	_municipality.fillFieldMap()

	return _municipality
}

type municipality struct {
	municipalityDo

	ALL                   field.Asterisk
	ID                    field.Int32  // 内部ID（主キー、自動採番）
	PrefectureCode        field.String // 都道府県ID（外部キー、都道府県マスタのID）
	OrganizationCode      field.String // 団体コード（総務省地方公共団体コード、6桁）
	PrefectureNameKanji   field.String // 都道府県名（漢字表記）
	MunicipalityNameKanji field.String // 市区町村名（漢字表記）
	PrefectureNameKana    field.String // 都道府県名（カタカナ表記）
	MunicipalityNameKana  field.String // 市区町村名（カタカナ表記）
	IsActive              field.Bool   // 有効フラグ（TRUE: 有効、FALSE: 無効）
	Prefecture            municipalityBelongsToPrefecture

	fieldMap map[string]field.Expr
}

func (m municipality) Table(newTableName string) *municipality {
	m.municipalityDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m municipality) As(alias string) *municipality {
	m.municipalityDo.DO = *(m.municipalityDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *municipality) updateTableName(table string) *municipality {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt32(table, "id")
	m.PrefectureCode = field.NewString(table, "prefecture_code")
	m.OrganizationCode = field.NewString(table, "organization_code")
	m.PrefectureNameKanji = field.NewString(table, "prefecture_name_kanji")
	m.MunicipalityNameKanji = field.NewString(table, "municipality_name_kanji")
	m.PrefectureNameKana = field.NewString(table, "prefecture_name_kana")
	m.MunicipalityNameKana = field.NewString(table, "municipality_name_kana")
	m.IsActive = field.NewBool(table, "is_active")

	m.fillFieldMap()

	return m
}

func (m *municipality) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *municipality) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 9)
	m.fieldMap["id"] = m.ID
	m.fieldMap["prefecture_code"] = m.PrefectureCode
	m.fieldMap["organization_code"] = m.OrganizationCode
	m.fieldMap["prefecture_name_kanji"] = m.PrefectureNameKanji
	m.fieldMap["municipality_name_kanji"] = m.MunicipalityNameKanji
	m.fieldMap["prefecture_name_kana"] = m.PrefectureNameKana
	m.fieldMap["municipality_name_kana"] = m.MunicipalityNameKana
	m.fieldMap["is_active"] = m.IsActive

}

func (m municipality) clone(db *gorm.DB) municipality {
	m.municipalityDo.ReplaceConnPool(db.Statement.ConnPool)
	m.Prefecture.db = db.Session(&gorm.Session{Initialized: true})
	m.Prefecture.db.Statement.ConnPool = db.Statement.ConnPool
	return m
}

func (m municipality) replaceDB(db *gorm.DB) municipality {
	m.municipalityDo.ReplaceDB(db)
	m.Prefecture.db = db.Session(&gorm.Session{})
	return m
}

type municipalityBelongsToPrefecture struct {
	db *gorm.DB

	field.RelationField
}

func (a municipalityBelongsToPrefecture) Where(conds ...field.Expr) *municipalityBelongsToPrefecture {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a municipalityBelongsToPrefecture) WithContext(ctx context.Context) *municipalityBelongsToPrefecture {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a municipalityBelongsToPrefecture) Session(session *gorm.Session) *municipalityBelongsToPrefecture {
	a.db = a.db.Session(session)
	return &a
}

func (a municipalityBelongsToPrefecture) Model(m *model.Municipality) *municipalityBelongsToPrefectureTx {
	return &municipalityBelongsToPrefectureTx{a.db.Model(m).Association(a.Name())}
}

func (a municipalityBelongsToPrefecture) Unscoped() *municipalityBelongsToPrefecture {
	a.db = a.db.Unscoped()
	return &a
}

type municipalityBelongsToPrefectureTx struct{ tx *gorm.Association }

func (a municipalityBelongsToPrefectureTx) Find() (result *model.Prefecture, err error) {
	return result, a.tx.Find(&result)
}

func (a municipalityBelongsToPrefectureTx) Append(values ...*model.Prefecture) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a municipalityBelongsToPrefectureTx) Replace(values ...*model.Prefecture) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a municipalityBelongsToPrefectureTx) Delete(values ...*model.Prefecture) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a municipalityBelongsToPrefectureTx) Clear() error {
	return a.tx.Clear()
}

func (a municipalityBelongsToPrefectureTx) Count() int64 {
	return a.tx.Count()
}

func (a municipalityBelongsToPrefectureTx) Unscoped() *municipalityBelongsToPrefectureTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type municipalityDo struct{ gen.DO }

type IMunicipalityDo interface {
	gen.SubQuery
	Debug() IMunicipalityDo
	WithContext(ctx context.Context) IMunicipalityDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMunicipalityDo
	WriteDB() IMunicipalityDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMunicipalityDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMunicipalityDo
	Not(conds ...gen.Condition) IMunicipalityDo
	Or(conds ...gen.Condition) IMunicipalityDo
	Select(conds ...field.Expr) IMunicipalityDo
	Where(conds ...gen.Condition) IMunicipalityDo
	Order(conds ...field.Expr) IMunicipalityDo
	Distinct(cols ...field.Expr) IMunicipalityDo
	Omit(cols ...field.Expr) IMunicipalityDo
	Join(table schema.Tabler, on ...field.Expr) IMunicipalityDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMunicipalityDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMunicipalityDo
	Group(cols ...field.Expr) IMunicipalityDo
	Having(conds ...gen.Condition) IMunicipalityDo
	Limit(limit int) IMunicipalityDo
	Offset(offset int) IMunicipalityDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMunicipalityDo
	Unscoped() IMunicipalityDo
	Create(values ...*model.Municipality) error
	CreateInBatches(values []*model.Municipality, batchSize int) error
	Save(values ...*model.Municipality) error
	First() (*model.Municipality, error)
	Take() (*model.Municipality, error)
	Last() (*model.Municipality, error)
	Find() ([]*model.Municipality, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Municipality, err error)
	FindInBatches(result *[]*model.Municipality, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Municipality) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMunicipalityDo
	Assign(attrs ...field.AssignExpr) IMunicipalityDo
	Joins(fields ...field.RelationField) IMunicipalityDo
	Preload(fields ...field.RelationField) IMunicipalityDo
	FirstOrInit() (*model.Municipality, error)
	FirstOrCreate() (*model.Municipality, error)
	FindByPage(offset int, limit int) (result []*model.Municipality, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMunicipalityDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m municipalityDo) Debug() IMunicipalityDo {
	return m.withDO(m.DO.Debug())
}

func (m municipalityDo) WithContext(ctx context.Context) IMunicipalityDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m municipalityDo) ReadDB() IMunicipalityDo {
	return m.Clauses(dbresolver.Read)
}

func (m municipalityDo) WriteDB() IMunicipalityDo {
	return m.Clauses(dbresolver.Write)
}

func (m municipalityDo) Session(config *gorm.Session) IMunicipalityDo {
	return m.withDO(m.DO.Session(config))
}

func (m municipalityDo) Clauses(conds ...clause.Expression) IMunicipalityDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m municipalityDo) Returning(value interface{}, columns ...string) IMunicipalityDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m municipalityDo) Not(conds ...gen.Condition) IMunicipalityDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m municipalityDo) Or(conds ...gen.Condition) IMunicipalityDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m municipalityDo) Select(conds ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m municipalityDo) Where(conds ...gen.Condition) IMunicipalityDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m municipalityDo) Order(conds ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m municipalityDo) Distinct(cols ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m municipalityDo) Omit(cols ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m municipalityDo) Join(table schema.Tabler, on ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m municipalityDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m municipalityDo) RightJoin(table schema.Tabler, on ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m municipalityDo) Group(cols ...field.Expr) IMunicipalityDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m municipalityDo) Having(conds ...gen.Condition) IMunicipalityDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m municipalityDo) Limit(limit int) IMunicipalityDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m municipalityDo) Offset(offset int) IMunicipalityDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m municipalityDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMunicipalityDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m municipalityDo) Unscoped() IMunicipalityDo {
	return m.withDO(m.DO.Unscoped())
}

func (m municipalityDo) Create(values ...*model.Municipality) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m municipalityDo) CreateInBatches(values []*model.Municipality, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m municipalityDo) Save(values ...*model.Municipality) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m municipalityDo) First() (*model.Municipality, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Municipality), nil
	}
}

func (m municipalityDo) Take() (*model.Municipality, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Municipality), nil
	}
}

func (m municipalityDo) Last() (*model.Municipality, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Municipality), nil
	}
}

func (m municipalityDo) Find() ([]*model.Municipality, error) {
	result, err := m.DO.Find()
	return result.([]*model.Municipality), err
}

func (m municipalityDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Municipality, err error) {
	buf := make([]*model.Municipality, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m municipalityDo) FindInBatches(result *[]*model.Municipality, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m municipalityDo) Attrs(attrs ...field.AssignExpr) IMunicipalityDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m municipalityDo) Assign(attrs ...field.AssignExpr) IMunicipalityDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m municipalityDo) Joins(fields ...field.RelationField) IMunicipalityDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m municipalityDo) Preload(fields ...field.RelationField) IMunicipalityDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m municipalityDo) FirstOrInit() (*model.Municipality, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Municipality), nil
	}
}

func (m municipalityDo) FirstOrCreate() (*model.Municipality, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Municipality), nil
	}
}

func (m municipalityDo) FindByPage(offset int, limit int) (result []*model.Municipality, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m municipalityDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m municipalityDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m municipalityDo) Delete(models ...*model.Municipality) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *municipalityDo) withDO(do gen.Dao) *municipalityDo {
	m.DO = *do.(*gen.DO)
	return m
}
